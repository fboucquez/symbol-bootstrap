#!/bin/bash
set -e

function try()
{
    [[ $- = *e* ]]; SAVED_OPT_E=$?
    set +e
}

function throw()
{
    exit $1
}

function catch()
{
    export ex_code=$?
    (( $SAVED_OPT_E )) && set +e
    return $ex_code
}

name=$1
mode=$2
waitForOther=$3
application="broker"
theOtherApplication="server"
config="./$application-config"

echo "RUNNING $application $name $mode"
export LD_LIBRARY_PATH={{{catapultAppFolder}}}/lib:{{{catapultAppFolder}}}/deps

ulimit -c unlimited

rm -f "{{{dataDirectory}}}/$application.started"
rm -f "{{{dataDirectory}}}/$application-recovery.started"

if [ "$mode" == "DEBUG" ]; then
  echo "Setting up core dump..."
  mkdir -p ./logs
  echo "./logs/$application.%e.%t" >/proc/sys/kernel/core_pattern
fi

if [ -e "{{{dataDirectory}}}/$application.lock" ]; then
  echo "!!!! Have lock file present, going to run recovery in $application mode...."

  while [ -f "{{{dataDirectory}}}/$theOtherApplication-recovery.started" ] ;
  do
      echo "Waiting for $theOtherApplication recovery to finish"
      sleep 1
  done

  touch "{{{dataDirectory}}}/$application-recovery.started"

  try
(
    set -e
    {{{catapultAppFolder}}}/bin/catapult.recovery "$config"
    echo "!!!! Finished running recovery, should be moving on to start $application..."
)
# directly after closing the subshell you need to connect a group to the catch using ||
catch || {
    echo "!!!! $application recovery has CRASHED!"
    rm -f "{{{dataDirectory}}}/recovery.lock"
    rm -f "{{{dataDirectory}}}/$application-recovery.started"
    throw $ex_code # you can rethrow the "exception" causing the script to exit if not caught
}
fi

if [ "$waitForOther" == "true" ]; then
  while [ ! -f "{{{dataDirectory}}}/$theOtherApplication.started" ] ;
  do
  echo "Waiting for $theOtherApplication to start"
  sleep 1
  done
fi

rm -f "{{{dataDirectory}}}/$application.lock"
rm -f "{{{dataDirectory}}}/$application-recovery.started"
touch "{{{dataDirectory}}}/$application.started"

(
    set -e
    echo "!!!! Starting $application...."
    {{{catapultAppFolder}}}/bin/catapult.broker "$config"
)
# directly after closing the subshell you need to connect a group to the catch using ||
catch || {
    echo "!!!! $application has CRASHED!"
    rm "{{{dataDirectory}}}/$application.started"
    throw $ex_code # you can rethrow the "exception" causing the script to exit if not caught
}
